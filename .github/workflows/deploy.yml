name: MLOps CI/CD Pipeline

on:
  push:
    branches: [main]
  workflow_dispatch:  # Manual trigger

env:
  DOCKER_REGISTRY: docker.io
  DOCKERHUB_USERNAME: sairam030
  BACKEND_IMAGE: sentiment-backend
  FRONTEND_IMAGE: sentiment-frontend

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 1: Pull Best Model from MLflow
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # After training locally with 'dvc repro', the best model is
  # registered in MLflow Model Registry. This job downloads it
  # along with comparison artifacts for deployment.
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  pull-model:
    name: ðŸŽ¯ Pull Best Model from MLflow
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
      
      - name: Install MLflow dependencies
        run: |
          pip install mlflow boto3 pyyaml python-dotenv
      
      - name: Download best model from MLflow
        env:
          # DagsHub credentials for MLflow tracking
          MLFLOW_TRACKING_USERNAME: ${{ secrets.DAGSHUB_USERNAME }}
          MLFLOW_TRACKING_PASSWORD: ${{ secrets.DAGSHUB_TOKEN }}
        run: |
          echo "ðŸ“¦ Downloading best model from MLflow Model Registry..."
          python scripts/pull_best_model.py --alias production --output aws_serving/app/artifacts
          
          echo "âœ… Model artifacts downloaded:"
          ls -lh aws_serving/app/artifacts/
      
      - name: Upload artifacts for next jobs
        uses: actions/upload-artifact@v4
        with:
          name: model-artifacts
          path: aws_serving/app/artifacts/
          retention-days: 7

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 2: Build Docker Images
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Build optimized Docker images for backend (Flask + models)
  # and frontend (Nginx reverse proxy).
  # Images are built but NOT pushed yet - that happens after tests.
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  build:
    name: ðŸ—ï¸ Build Docker Images
    runs-on: ubuntu-latest
    needs: pull-model
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download model artifacts
        uses: actions/download-artifact@v4
        with:
          name: model-artifacts
          path: aws_serving/app/artifacts/
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build backend image
        run: |
          cd aws_serving/app
          docker build -t ${{ env.DOCKERHUB_USERNAME }}/${{ env.BACKEND_IMAGE }}:test .
          
          echo "âœ… Backend image built:"
          docker images | grep sentiment-backend
      
      - name: Build frontend image
        run: |
          cd aws_serving/frontend
          docker build -t ${{ env.DOCKERHUB_USERNAME }}/${{ env.FRONTEND_IMAGE }}:test .
          
          echo "âœ… Frontend image built:"
          docker images | grep sentiment-frontend
      
      - name: Save images as tar files
        run: |
          docker save ${{ env.DOCKERHUB_USERNAME }}/${{ env.BACKEND_IMAGE }}:test \
            -o backend-image.tar
          docker save ${{ env.DOCKERHUB_USERNAME }}/${{ env.FRONTEND_IMAGE }}:test \
            -o frontend-image.tar
      
      - name: Upload Docker images
        uses: actions/upload-artifact@v4
        with:
          name: docker-images
          path: |
            backend-image.tar
            frontend-image.tar
          retention-days: 7

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 3: Lint & Code Quality
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Run static analysis tools to catch code quality issues:
  # - flake8: Python linting (PEP8 compliance)
  # - black: Code formatting check
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  lint:
    name: ðŸ” Lint & Code Quality
    runs-on: ubuntu-latest
    needs: build
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
      
      - name: Install linting tools
        run: |
          pip install flake8 black isort
      
      - name: Run flake8
        run: |
          echo "ðŸ” Running flake8 linter..."
          flake8 aws_serving/app/ \
            --max-line-length=120 \
            --exclude=__pycache__,.git,artifacts \
            --ignore=E203,W503
      
      - name: Run black (check mode)
        run: |
          echo "ðŸŽ¨ Checking code formatting with black..."
          black --check aws_serving/app/ --exclude="artifacts|__pycache__"
      
      - name: Run isort (check mode)
        run: |
          echo "ðŸ“¦ Checking import order with isort..."
          isort --check-only aws_serving/app/ \
            --skip-glob="artifacts/*" --skip-glob="__pycache__/*"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 4: Unit Tests
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Run pytest unit tests to verify:
  # - API endpoints work correctly
  # - Model loading is successful
  # - Database connections are valid
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # test:
  #   name: ðŸ§ª Run Unit Tests
  #   runs-on: ubuntu-latest
  #   needs: build
    
  #   services:
  #     # Start PostgreSQL for testing database functionality
  #     postgres:
  #       image: postgres:15-alpine
  #       env:
  #         POSTGRES_DB: test_db
  #         POSTGRES_USER: test_user
  #         POSTGRES_PASSWORD: test_password
  #       ports:
  #         - 5432:5432
  #       options: >-
  #         --health-cmd pg_isready
  #         --health-interval 10s
  #         --health-timeout 5s
  #         --health-retries 5
    
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4
      
  #     - name: Set up Python
  #       uses: actions/setup-python@v5
  #       with:
  #         python-version: '3.10'
      
  #     - name: Download model artifacts
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: model-artifacts
  #         path: aws_serving/app/artifacts/
      
  #     - name: Install test dependencies
  #       run: |
  #         pip install -r serving/requirements.txt
  #         pip install pytest pytest-cov pytest-mock

  #     - name: Run pytest
  #       env:
  #         DATABASE_URL: postgresql://test_user:test_password@localhost:5432/test_db
  #         DATABASE_SSL: disable
  #       run: |
  #         echo "ðŸ§ª Running unit tests with pytest..."
  #         pytest tests/ -v --cov=serving --cov-report=term-missing

  #     - name: Upload coverage report
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: coverage-report
  #         path: .coverage
  #         retention-days: 7

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 5: Push to Docker Hub
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # After tests pass, push images to Docker Hub with ':test' tag.
  # These images will be deployed to the test environment.
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  push-dockerhub:
    name: ðŸ“¤ Push to Docker Hub (:test)
    runs-on: ubuntu-latest
    needs: [lint]
    
    steps:
      - name: Download Docker images
        uses: actions/download-artifact@v4
        with:
          name: docker-images
      
      - name: Load Docker images
        run: |
          docker load -i backend-image.tar
          docker load -i frontend-image.tar
          
          echo "âœ… Images loaded:"
          docker images | grep sentiment
      
      - name: Debug secret (check token is set)
        env:
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          echo "Token length: ${#DOCKERHUB_TOKEN}"
          if [ -z "${DOCKERHUB_TOKEN}" ]; then
            echo "âŒ DOCKERHUB_TOKEN is EMPTY - secret not saved correctly!"
            exit 1
          else
            echo "âœ… DOCKERHUB_TOKEN is set (length: ${#DOCKERHUB_TOKEN})"
          fi

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}


      - name: Push images with :test tag
        run: |
          echo "ðŸ“¤ Pushing backend:test..."
          docker push ${{ env.DOCKERHUB_USERNAME }}/${{ env.BACKEND_IMAGE }}:test
          
          echo "ðŸ“¤ Pushing frontend:test..."
          docker push ${{ env.DOCKERHUB_USERNAME }}/${{ env.FRONTEND_IMAGE }}:test
          
          echo "âœ… Images pushed to Docker Hub with :test tag"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 6: Deploy to Test Environment (EC2)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SSH into test EC2 instance and deploy with docker-compose.
  # This environment is used for integration testing before prod.
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  deploy-test:
    name: ðŸš€ Deploy to Test Environment
    runs-on: ubuntu-latest
    needs: push-dockerhub
    environment:
      name: test
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH keys
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.TEST_EC2_SSH_KEY }}" > ~/.ssh/test_key
          chmod 600 ~/.ssh/test_key
          ssh-keyscan -H ${{ secrets.TEST_FRONTEND_HOST }} >> ~/.ssh/known_hosts

      - name: Copy files and SSH key to frontend EC2
        run: |
          scp -i ~/.ssh/test_key \
            aws_serving/docker-compose.frontend.yml \
            aws_serving/docker-compose.backend.yml \
            ~/.ssh/test_key \
            ${{ secrets.TEST_FRONTEND_USER }}@${{ secrets.TEST_FRONTEND_HOST }}:~/

      - name: Deploy backend (via SSH jump through frontend)
        run: |
          ssh -i ~/.ssh/test_key ${{ secrets.TEST_FRONTEND_USER }}@${{ secrets.TEST_FRONTEND_HOST }} << 'EOF'
            echo "ðŸš€ Deploying BACKEND to ${{ secrets.TEST_BACKEND_HOST }}..."

            # Setup key for backend SSH
            chmod 600 ~/test_key

            # Add backend host to known_hosts
            ssh-keyscan -H ${{ secrets.TEST_BACKEND_HOST }} >> ~/.ssh/known_hosts 2>/dev/null

            # Copy backend compose file to backend EC2
            scp -i ~/test_key ~/docker-compose.backend.yml \
              ${{ secrets.TEST_BACKEND_USER }}@${{ secrets.TEST_BACKEND_HOST }}:~/docker-compose.yml

            # Deploy on backend EC2
            ssh -i ~/test_key ${{ secrets.TEST_BACKEND_USER }}@${{ secrets.TEST_BACKEND_HOST }} << 'INNER'
              echo "ðŸ“¦ Backend EC2 deployment starting..."
              docker compose down || true
              docker system prune -af --volumes || true
              df -h /
              docker pull sairam030/sentiment-backend:test
              export DATABASE_URL="${{ secrets.RDS_DATABASE_URL }}"
              docker compose up -d
              echo "â³ Waiting for model to load..."
              sleep 30
              echo "âœ… Backend deployment complete"
              docker ps
            INNER

            # Clean up SSH key from frontend
            rm -f ~/test_key
          EOF

      - name: Deploy frontend on frontend EC2
        run: |
          ssh -i ~/.ssh/test_key ${{ secrets.TEST_FRONTEND_USER }}@${{ secrets.TEST_FRONTEND_HOST }} << 'EOF'
            echo "ðŸš€ Deploying FRONTEND..."

            # Stop existing frontend
            docker compose -f docker-compose.frontend.yml down || true

            # Clean up
            docker system prune -af --volumes || true

            # Pull frontend image
            docker pull sairam030/sentiment-frontend:test

            # Start frontend (points to backend private IP)
            docker compose -f docker-compose.frontend.yml up -d

            echo "âœ… Frontend deployment complete"
            docker ps
          EOF

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 7: Smoke Tests
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Verify the test deployment is working:
  # - Health check endpoint responds
  # - Sample prediction works
  # - Dashboard is accessible
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  smoke-test:
    name: ðŸ’¨ Smoke Tests (Test Environment)
    runs-on: ubuntu-latest
    needs: deploy-test
    
    steps:
      - name: Wait for services to start
        run: sleep 60
      
      - name: Health check
        run: |
          echo "ðŸ¥ Testing health endpoint..."
          response=$(curl -s -o /dev/null -w "%{http_code}" \
            http://${{ secrets.TEST_FRONTEND_HOST }}/api/health)
          
          if [ "$response" -eq 200 ]; then
            echo "âœ… Health check passed (200)"
          else
            echo "âŒ Health check failed ($response)"
            exit 1
          fi
      
      - name: Test prediction endpoint
        run: |
          echo "ðŸ§ª Testing prediction..."
          response=$(curl -s -X POST \
            http://${{ secrets.TEST_FRONTEND_HOST }}/api/predict \
            -H "Content-Type: application/json" \
            -d '{"text": "This is a test comment"}')
          
          echo "Response: $response"
          
          # Check if response contains expected fields
          if echo "$response" | grep -q "prediction"; then
            echo "âœ… Prediction endpoint works"
          else
            echo "âŒ Prediction endpoint failed"
            exit 1
          fi
      
      - name: Test dashboard access
        run: |
          echo "ðŸ“Š Testing dashboard..."
          response=$(curl -s -o /dev/null -w "%{http_code}" \
            http://${{ secrets.TEST_FRONTEND_HOST }}/dashboard)
          
          if [ "$response" -eq 200 ]; then
            echo "âœ… Dashboard accessible (200)"
          else
            echo "âŒ Dashboard not accessible ($response)"
            exit 1
          fi
      
      - name: Smoke test summary
        run: |
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  âœ… All smoke tests passed!"
          echo "  ðŸŒ Test environment: http://${{ secrets.TEST_FRONTEND_HOST }}"
          echo "  ðŸ“Š Dashboard: http://${{ secrets.TEST_FRONTEND_HOST }}/dashboard"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 8: Manual Approval Gate
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # IMPORTANT: This job requires manual approval in GitHub UI.
  # 
  # To set up:
  # 1. Go to: Settings â†’ Environments â†’ New environment
  # 2. Name: "production"
  # 3. Enable "Required reviewers" and add yourself
  # 4. Save protection rules
  # 
  # When pipeline reaches this stage, you'll get a notification
  # to review and approve the production deployment.
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  approve-prod:
    name: â¸ï¸  Manual Approval Required
    runs-on: ubuntu-latest
    needs: smoke-test
    environment:
      name: production-approval
    
    steps:
      - name: Waiting for approval
        run: |
          echo "â¸ï¸  Waiting for manual approval to deploy to PRODUCTION..."
          echo ""
          echo "Review test environment at: http://${{ secrets.TEST_FRONTEND_HOST }}"
          echo "Dashboard: http://${{ secrets.TEST_FRONTEND_HOST }}/dashboard"
          echo ""
          echo "If everything looks good, approve this deployment."

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 9: Tag as Production
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # After approval, retag :test images as :prod in Docker Hub.
  # This creates a stable production tag while keeping test tag.
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  tag-production:
    name: ðŸ·ï¸  Tag as :prod
    runs-on: ubuntu-latest
    needs: approve-prod
    
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Pull :test images
        run: |
          docker pull ${{ env.DOCKERHUB_USERNAME }}/${{ env.BACKEND_IMAGE }}:test
          docker pull ${{ env.DOCKERHUB_USERNAME }}/${{ env.FRONTEND_IMAGE }}:test
      
      - name: Tag as :prod
        run: |
          docker tag \
            ${{ env.DOCKERHUB_USERNAME }}/${{ env.BACKEND_IMAGE }}:test \
            ${{ env.DOCKERHUB_USERNAME }}/${{ env.BACKEND_IMAGE }}:prod
          
          docker tag \
            ${{ env.DOCKERHUB_USERNAME }}/${{ env.FRONTEND_IMAGE }}:test \
            ${{ env.DOCKERHUB_USERNAME }}/${{ env.FRONTEND_IMAGE }}:prod
      
      - name: Push :prod tags
        run: |
          echo "ðŸ“¤ Pushing backend:prod..."
          docker push ${{ env.DOCKERHUB_USERNAME }}/${{ env.BACKEND_IMAGE }}:prod
          
          echo "ðŸ“¤ Pushing frontend:prod..."
          docker push ${{ env.DOCKERHUB_USERNAME }}/${{ env.FRONTEND_IMAGE }}:prod
          
          echo "âœ… Production images tagged and pushed"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 10: Deploy to Production
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Final stage: Deploy :prod images to production EC2.
  # Uses blue-green deployment strategy to minimize downtime.
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  deploy-prod:
    name: ðŸš€ Deploy to Production
    runs-on: ubuntu-latest
    needs: tag-production
    environment:
      name: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PROD_EC2_SSH_KEY }}" > ~/.ssh/prod_key
          chmod 600 ~/.ssh/prod_key
          ssh-keyscan -H ${{ secrets.PROD_FRONTEND_HOST }} >> ~/.ssh/known_hosts
      
      - name: Copy deployment files to prod EC2
        run: |
          scp -i ~/.ssh/prod_key \
            aws_serving/docker-compose.prod.yml \
            ${{ secrets.PROD_FRONTEND_USER }}@${{ secrets.PROD_FRONTEND_HOST }}:~/docker-compose.yml
      
      - name: Deploy to production
        run: |
          ssh -i ~/.ssh/prod_key ${{ secrets.PROD_FRONTEND_USER }}@${{ secrets.PROD_FRONTEND_HOST }} << 'EOF'
            echo "ðŸš€ Deploying to PRODUCTION..."
            
            # Pull :prod images
            docker pull ${{ env.DOCKERHUB_USERNAME }}/${{ env.BACKEND_IMAGE }}:prod
            docker pull ${{ env.DOCKERHUB_USERNAME }}/${{ env.FRONTEND_IMAGE }}:prod
            
            # Blue-green deployment: Start new containers before stopping old
            export DATABASE_URL="${{ secrets.RDS_DATABASE_URL }}"
            export DATABASE_SSL="require"
            export BACKEND_HOST="${{ secrets.PROD_BACKEND_HOST }}"
            export BACKEND_PORT="5000"
            
            docker compose up -d --no-deps --build
            
            # Wait for health check
            sleep 10
            
            # Remove old containers
            docker compose down --remove-orphans || true
            
            echo "âœ… Production deployment complete"
            docker ps
          EOF
      
      - name: Production health check
        run: |
          echo "ðŸ¥ Final health check..."
          response=$(curl -s -o /dev/null -w "%{http_code}" \
            http://${{ secrets.PROD_FRONTEND_HOST }}/api/health)
          
          if [ "$response" -eq 200 ]; then
            echo "âœ… Production is healthy!"
          else
            echo "âš ï¸  Production health check returned $response"
            exit 1
          fi
      
      - name: Deployment summary
        run: |
          echo ""
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘  ðŸŽ‰ PRODUCTION DEPLOYMENT SUCCESSFUL!              â•‘"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘  ðŸŒ Production URL:                                â•‘"
          echo "â•‘     http://${{ secrets.PROD_FRONTEND_HOST }}            â•‘"
          echo "â•‘  ðŸ“Š Dashboard:                                     â•‘"
          echo "â•‘     http://${{ secrets.PROD_FRONTEND_HOST }}/dashboard  â•‘"
          echo "â•‘  ðŸ³ Docker Images:                                 â•‘"
          echo "â•‘     ${{ env.DOCKERHUB_USERNAME }}/${{ env.BACKEND_IMAGE }}:prod"
          echo "â•‘     ${{ env.DOCKERHUB_USERNAME }}/${{ env.FRONTEND_IMAGE }}:prod"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
